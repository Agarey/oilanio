{"version":3,"file":"index.js","sources":["../src/index.ts"],"sourcesContent":["import {\n  MouseEvent as ReactMouseEvent,\n  MouseEventHandler,\n  TouchEvent as ReactTouchEvent,\n  TouchEventHandler,\n  useCallback,\n  useEffect,\n  useRef,\n} from 'react';\n\nfunction isTouchEvent<Target>(event: LongPressEvent<Target>): event is ReactTouchEvent<Target> {\n  const { nativeEvent } = event;\n  return window.TouchEvent ? nativeEvent instanceof TouchEvent : 'touches' in nativeEvent;\n}\nfunction isMouseEvent<Target>(event: LongPressEvent<Target>): event is ReactMouseEvent<Target> {\n  return event.nativeEvent instanceof MouseEvent;\n}\n\ntype Coordinates = {\n  x: number;\n  y: number;\n} | null;\n\nfunction getCurrentPosition<Target>(event: LongPressEvent<Target>): Coordinates {\n  if (isTouchEvent(event)) {\n    return {\n      x: event.touches[0].pageX,\n      y: event.touches[0].pageY,\n    };\n  }\n\n  /* istanbul ignore else */\n  if (isMouseEvent(event)) {\n    return {\n      x: event.pageX,\n      y: event.pageY,\n    };\n  }\n\n  /* istanbul ignore next */\n  return null;\n}\n\nexport type LongPressEvent<Target = Element> = ReactMouseEvent<Target> | ReactTouchEvent<Target>;\nexport type LongPressCallback<Target = Element> = (event?: LongPressEvent<Target>) => void;\nexport enum LongPressDetectEvents {\n  BOTH = 'both',\n  MOUSE = 'mouse',\n  TOUCH = 'touch',\n}\n\nexport type LongPressResult<\n  Target,\n  DetectType extends LongPressDetectEvents = LongPressDetectEvents.BOTH\n> = DetectType extends LongPressDetectEvents.BOTH\n  ? {\n      onMouseDown: MouseEventHandler<Target>;\n      onMouseUp: MouseEventHandler<Target>;\n      onMouseMove: MouseEventHandler<Target>;\n      onMouseLeave: MouseEventHandler<Target>;\n      onTouchStart: TouchEventHandler<Target>;\n      onTouchMove: TouchEventHandler<Target>;\n      onTouchEnd: TouchEventHandler<Target>;\n    }\n  : DetectType extends LongPressDetectEvents.MOUSE\n  ? {\n      onMouseDown: MouseEventHandler<Target>;\n      onMouseUp: MouseEventHandler<Target>;\n      onMouseMove: MouseEventHandler<Target>;\n      onMouseLeave: MouseEventHandler<Target>;\n    }\n  : DetectType extends LongPressDetectEvents.TOUCH\n  ? {\n      onTouchStart: TouchEventHandler<Target>;\n      onTouchMove: TouchEventHandler<Target>;\n      onTouchEnd: TouchEventHandler<Target>;\n    }\n  : never;\n\nexport interface LongPressOptions<Target = Element> {\n  threshold?: number;\n  captureEvent?: boolean;\n  detect?: LongPressDetectEvents;\n  filterEvents?: (event: LongPressEvent<Target>) => boolean;\n  cancelOnMovement?: boolean | number;\n  onStart?: LongPressCallback<Target>;\n  onMove?: LongPressCallback<Target>;\n  onFinish?: LongPressCallback<Target>;\n  onCancel?: LongPressCallback<Target>;\n}\n\nexport function useLongPress<Target = Element>(\n  callback: null,\n  options?: LongPressOptions<Target>\n): Record<string, never>;\nexport function useLongPress<Target = Element, Callback extends LongPressCallback<Target> = LongPressCallback<Target>>(\n  callback: Callback,\n  options?: LongPressOptions<Target>\n): LongPressResult<Target>;\nexport function useLongPress<Target = Element, Callback extends LongPressCallback<Target> = LongPressCallback<Target>>(\n  callback: Callback | null,\n  options?: LongPressOptions<Target>\n): LongPressResult<Target> | Record<string, never>;\n/**\n * Detect click / tap and hold event\n *\n * @param callback <p>\n *   Function to call when long press event is detected\n *   (click or tap lasts for <i>threshold</i> amount of time or longer)\n *   </p>\n * @param options <ul>\n * <li><b>threshold</b>\n * - Period of time that must elapse after detecting click or tap in order to trigger <i>callback</i></li>\n * <li><b>captureEvent</b>\n * - If React Event will be supplied as first argument to all callbacks</li>\n * <li><b>detect</b>\n * - Which type of events should be detected ('mouse' | 'touch' | 'both' )\n * <li><b>cancelOnMovement</b>\n * - <p>If long press should be canceled on mouse / touch move.</p>\n * <p>You can use this option to turn it on / off or set specific move tolerance as follows:</p>\n * <ol><li><i>true</i> or <i>false</i> (by default) - when set to true tolerance value will default to <i>25px</i>\n * <li><i>number</i> - set a specific tolerance value (square size inside which movement won't cancel long press)</li></ol>\n * </li>\n * <li><b>onStart</b>\n * - Called right after detecting click / tap event (e.g. onMouseDown or onTouchStart)\n * <li><b>onFinish</b>\n * - Called (if long press <u>was triggered</u>)\n * on releasing click or tap (e.g. onMouseUp, onMouseLeave or onTouchEnd)\n * <li><b>onCancel</b>\n * - Called (if long press <u>was <b>not</b> triggered</u>)\n * on releasing click or tap (e.g. onMouseUp, onMouseLeave or onTouchEnd)\n * </ul>\n */\nexport function useLongPress<\n  Target extends Element = Element,\n  Callback extends LongPressCallback<Target> = LongPressCallback<Target>\n>(\n  callback: Callback | null,\n  {\n    threshold = 400,\n    captureEvent = false,\n    detect = LongPressDetectEvents.BOTH,\n    cancelOnMovement = false,\n    filterEvents,\n    onStart,\n    onMove,\n    onFinish,\n    onCancel,\n  }: LongPressOptions<Target> = {}\n): LongPressResult<Target, typeof detect> | Record<string, never> {\n  const isLongPressActive = useRef(false);\n  const isPressed = useRef(false);\n  const timer = useRef<NodeJS.Timeout>();\n  const savedCallback = useRef(callback);\n  const startPosition = useRef<Coordinates>(null);\n\n  const start = useCallback(\n    (event: LongPressEvent<Target>) => {\n      // Prevent multiple start triggers\n      if (isPressed.current) {\n        return;\n      }\n\n      // Ignore events other than mouse and touch\n      if (!isMouseEvent(event) && !isTouchEvent(event)) {\n        return;\n      }\n\n      // If we don't want all events to trigger long press and provided event is filtered out\n      if (filterEvents !== undefined && !filterEvents(event)) {\n        return;\n      }\n\n      startPosition.current = getCurrentPosition(event);\n\n      if (captureEvent) {\n        event.persist();\n      }\n\n      // When touched trigger onStart and start timer\n      captureEvent ? onStart?.(event) : onStart?.();\n      isPressed.current = true;\n      timer.current = setTimeout(() => {\n        if (savedCallback.current) {\n          captureEvent ? savedCallback.current(event) : savedCallback.current();\n          isLongPressActive.current = true;\n        }\n      }, threshold);\n    },\n    [captureEvent, filterEvents, onStart, threshold]\n  );\n\n  const cancel = useCallback(\n    (event: LongPressEvent<Target>) => {\n      // Ignore events other than mouse and touch\n      if (!isMouseEvent(event) && !isTouchEvent(event)) {\n        return;\n      }\n\n      startPosition.current = null;\n\n      if (captureEvent) {\n        event.persist();\n      }\n\n      // Trigger onFinish callback only if timer was active\n      if (isLongPressActive.current) {\n        captureEvent ? onFinish?.(event) : onFinish?.();\n      } else if (isPressed.current) {\n        // Otherwise if not active trigger onCancel\n        captureEvent ? onCancel?.(event) : onCancel?.();\n      }\n      isLongPressActive.current = false;\n      isPressed.current = false;\n      timer.current !== undefined && clearTimeout(timer.current);\n    },\n    [captureEvent, onFinish, onCancel]\n  );\n\n  const handleMove = useCallback(\n    (event: LongPressEvent<Target>) => {\n      captureEvent ? onMove?.(event) : onMove?.();\n      if (cancelOnMovement && startPosition.current) {\n        const currentPosition = getCurrentPosition(event);\n        /* istanbul ignore else */\n        if (currentPosition) {\n          const moveThreshold = cancelOnMovement === true ? 25 : cancelOnMovement;\n          const movedDistance = {\n            x: Math.abs(currentPosition.x - startPosition.current.x),\n            y: Math.abs(currentPosition.y - startPosition.current.y),\n          };\n\n          // If moved outside move tolerance box then cancel long press\n          if (movedDistance.x > moveThreshold || movedDistance.y > moveThreshold) {\n            cancel(event);\n          }\n        }\n      }\n    },\n    [cancel, cancelOnMovement, captureEvent, onMove]\n  );\n\n  useEffect(\n    () => (): void => {\n      // Clear timeout on unmount\n      timer.current !== undefined && clearTimeout(timer.current);\n    },\n    []\n  );\n\n  useEffect(() => {\n    savedCallback.current = callback;\n  }, [callback]);\n\n  const mouseHandlers = {\n    onMouseDown: start as MouseEventHandler<Target>,\n    onMouseMove: handleMove as MouseEventHandler<Target>,\n    onMouseUp: cancel as MouseEventHandler<Target>,\n    onMouseLeave: cancel as MouseEventHandler<Target>,\n  };\n\n  const touchHandlers = {\n    onTouchStart: start as TouchEventHandler<Target>,\n    onTouchMove: handleMove as TouchEventHandler<Target>,\n    onTouchEnd: cancel as TouchEventHandler<Target>,\n  };\n\n  if (callback === null) {\n    return {};\n  }\n\n  if (detect === LongPressDetectEvents.MOUSE) {\n    return mouseHandlers;\n  }\n\n  if (detect === LongPressDetectEvents.TOUCH) {\n    return touchHandlers;\n  }\n\n  return { ...mouseHandlers, ...touchHandlers };\n}\n"],"names":["LongPressDetectEvents","isTouchEvent","event","nativeEvent","window","TouchEvent","isMouseEvent","MouseEvent","getCurrentPosition","x","touches","pageX","y","pageY","callback","threshold","captureEvent","detect","BOTH","cancelOnMovement","filterEvents","onStart","onMove","onFinish","onCancel","isLongPressActive","useRef","isPressed","timer","savedCallback","startPosition","start","useCallback","current","undefined","persist","setTimeout","cancel","clearTimeout","handleMove","currentPosition","moveThreshold","movedDistance","Math","abs","useEffect","mouseHandlers","onMouseDown","onMouseMove","onMouseUp","onMouseLeave","touchHandlers","onTouchStart","onTouchMove","onTouchEnd","MOUSE","TOUCH"],"mappings":"IA6CYA,oOAnCZ,SAASC,EAAqBC,GAC5B,IAAQC,EAAgBD,EAAhBC,YACR,OAAOC,OAAOC,WAAaF,aAAuBE,WAAa,YAAaF,EAE9E,SAASG,EAAqBJ,GAC5B,OAAOA,EAAMC,uBAAuBI,WAQtC,SAASC,EAA2BN,GAClC,OAAID,EAAaC,GACR,CACLO,EAAGP,EAAMQ,QAAQ,GAAGC,MACpBC,EAAGV,EAAMQ,QAAQ,GAAGG,OAKpBP,EAAaJ,GACR,CACLO,EAAGP,EAAMS,MACTC,EAAGV,EAAMW,YAUHb,sCAAAA,EAAAA,gCAAAA,+CAAAA,gBAAAA,8CA4FVc,sBAW8B,SAT5BC,UAAAA,aAAY,UACZC,aAAAA,oBACAC,OAAAA,aAASjB,8BAAsBkB,WAC/BC,iBAAAA,gBACAC,IAAAA,aACAC,IAAAA,QACAC,IAAAA,OACAC,IAAAA,SACAC,IAAAA,SAGIC,EAAoBC,UAAO,GAC3BC,EAAYD,UAAO,GACnBE,EAAQF,WACRG,EAAgBH,SAAOZ,GACvBgB,EAAgBJ,SAAoB,MAEpCK,EAAQC,cACZ,SAAC9B,GAEKyB,EAAUM,UAKT3B,EAAaJ,IAAWD,EAAaC,WAKrBgC,IAAjBd,GAA+BA,EAAalB,MAIhD4B,EAAcG,QAAUzB,EAAmBN,GAEvCc,GACFd,EAAMiC,UAIRnB,QAAeK,GAAAA,EAAUnB,SAASmB,GAAAA,IAClCM,EAAUM,SAAU,EACpBL,EAAMK,QAAUG,WAAW,WACrBP,EAAcI,UAChBjB,EAAea,EAAcI,QAAQ/B,GAAS2B,EAAcI,UAC5DR,EAAkBQ,SAAU,IAE7BlB,KAEL,CAACC,EAAcI,EAAcC,EAASN,IAGlCsB,EAASL,cACb,SAAC9B,IAEMI,EAAaJ,IAAWD,EAAaC,MAI1C4B,EAAcG,QAAU,KAEpBjB,GACFd,EAAMiC,UAIJV,EAAkBQ,QACpBjB,QAAeO,GAAAA,EAAWrB,SAASqB,GAAAA,IAC1BI,EAAUM,UAEnBjB,QAAeQ,GAAAA,EAAWtB,SAASsB,GAAAA,KAErCC,EAAkBQ,SAAU,EAC5BN,EAAUM,SAAU,OACFC,IAAlBN,EAAMK,SAAyBK,aAAaV,EAAMK,WAEpD,CAACjB,EAAcO,EAAUC,IAGrBe,EAAaP,cACjB,SAAC9B,GAEC,GADAc,QAAeM,GAAAA,EAASpB,SAASoB,GAAAA,IAC7BH,GAAoBW,EAAcG,QAAS,CAC7C,IAAMO,EAAkBhC,EAAmBN,GAE3C,GAAIsC,EAAiB,CACnB,IAAMC,GAAqC,IAArBtB,EAA4B,GAAKA,EACjDuB,EAAgB,CACpBjC,EAAGkC,KAAKC,IAAIJ,EAAgB/B,EAAIqB,EAAcG,QAAQxB,GACtDG,EAAG+B,KAAKC,IAAIJ,EAAgB5B,EAAIkB,EAAcG,QAAQrB,KAIpD8B,EAAcjC,EAAIgC,GAAiBC,EAAc9B,EAAI6B,IACvDJ,EAAOnC,MAKf,CAACmC,EAAQlB,EAAkBH,EAAcM,IAG3CuB,YACE,kCAEoBX,IAAlBN,EAAMK,SAAyBK,aAAaV,EAAMK,WAEpD,IAGFY,YAAU,WACRhB,EAAcI,QAAUnB,GACvB,CAACA,IAEJ,IAAMgC,EAAgB,CACpBC,YAAahB,EACbiB,YAAaT,EACbU,UAAWZ,EACXa,aAAcb,GAGVc,EAAgB,CACpBC,aAAcrB,EACdsB,YAAad,EACbe,WAAYjB,GAGd,OAAiB,OAAbvB,EACK,GAGLG,IAAWjB,8BAAsBuD,MAC5BT,EAGL7B,IAAWjB,8BAAsBwD,MAC5BL,OAGGL,EAAkBK"}